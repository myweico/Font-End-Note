- 表达式是一个短语，JS解析器都会将其计算得出一个结果。

# 内容结构
```
graph LR
0[第四章] --- 1[表达式分类]
1 --- 1.1[原始表达式]
1 --- 1.2[初始化表达式]
1 --- 1.3[函数定义表达式]
1 --- 1.4[属性访问表达式]
1 --- 1.5[调用表达式]
1 --- 1.6[创建对象表达式]

0 --- 2[运算符]
2 --- 2.1[+二元运算符]
2 --- 2.2[一元运算符+/-/++/--]
2 --- 2.3[位运算符]
2 --- 2.4[关系运算符]
2 --- 2.5[in运算符]
2 --- 2.6[instanceof运算符]
2 --- 2.7[逻辑运算符]
2 --- 2.8[赋值运算符]
2 --- 2.9[eval运算符]
2 --- 2.10[?:条件运算符]
2 --- 2.11[typeof运算符]
2 --- 2.12[delete运算符]
2 --- 2.13[void运算符]
2 --- 2.14[逗号运算符]

```

## 原始表达式
- 原始表达式就是最简单的表达式，是表达式的最小单位，包括了常量（直接量）、关键字和变量。
```js
//常量（直接量）
1.23                // 数字直接量
"Weico"             // 字符串直接量
/pattern/           // 正则表达式直接量

//保留字
true                // 返回布尔值：真
false               // 返回布尔值：假
null                // 返回一个值：空
this                // 返回“当前”对象

//变量
i                   // 返回变量i的值
sum                 // 返回sum的值
undefined           // undefined是一个全局变量
```
## 对象和数组的初始化表达式
```js
[]                          // 空数组
[1+2, 3+4]
var matrix = [[1,2,3],[4,5,6],[7,8,9]];
var sparseArray = [1,,,,5]  // 忽略的元素会被填充undefined,后面若填写逗号","将忽略

var p = { x:2.3, y:-1.2 };
var q = {};
q.x = 2.3; q.y = -1.2;

var side = 1;
var rectangle = { 
    upperLeft: { x:2, y:2 }
    lowerRight: { x:4, y:5 }
}

var side = 1;
var square = { 
    "upperLeft": { x: p.x, y: p.y},
    'lowerRight': { x: p.x + side, y: p.y + side}
}
```

## 函数定义表达式
```js 
var square =  function(x) { return x * x; };
```

## 属性访问表达式
```js
expression.identifier
expression[expression]

var o = { x: 1, y: {z:3};};
var a = [o, 4, [5,6]];
o.x         //1

o.y.z       //3

o["x"]      //1

a[1]        //4

a[2]["1"]   //6

a[0].x      //1
```
- 首先计算"."和"[]"之前的表达式，若为null或undefined则抛出类型错误异常

## 调用表达式
```js
f(0)                
Math.max(x,y,z)     
a.sort()            
```

## 创建对象表达式
```js
new Object()
new Point(2,3)

// 若不需要传入任意参数给构造函数，则不需要写圆括号
new Object
new Date
```
- 构造函数中的this可以替代新建的对象，使用this可以为新建的对象创建属性
- 如果一个构造函数确实返回了一个对象值，那么这个对象就可以作为整个对象创建的表达式的值，新创建的对象就废弃了

## 运算符概述
- 运算符包括标点符号运算符以及关键字运算符（delete或者instanceof）
- 运算符都是有优先级的
- 运算符都有自己期望的数据类型，并根据其进行类型转换
- 结合性指定了具有相同优先级的的运算符表达式中运算的顺序
- 左值就是出现在赋值符号左边的值，其可以是变量、对象属性、数组元素
- 若表达式的结果对后续某些变量等的值产生影响，则称该表达式具有副作用

##### 运算符的结合性
```js
w = x - y - z; 。  <-> w = ((x - y) - z);
x = ~-y            <-> x = ~(-y);
w = x = y = z;     <-> w = (x = ( y = z));
q = a?b:c?d:e?f:g; <-> q = a?b:(c?d:(e?f:g));
```
- **注意一元操作符、赋值和三元运算符都是从右到左结合的**

##### 运算顺序
- 子表达式都是从左到右进行计算的
- `b=(a++)+a`：1.先计算b 2.计算a++（假设为c) 3.计算a 4.计算c+a 5.赋值给b

### 运算符
##### " + " 运算符
- 优先进行字符串连接操作，两个操作数中有一个为字符串即进行字符串连接操作。否则，进行算数加法操作。
- 若其中有一个为对象。若对象为日期对象，优先使用toString()，其他对象优先使用valueOf()进行转换。转换后，若有一个是字符串则都转换为字符串进行连接操作。否则都转换成数字进行加法操作。
```js
1 + 2           // 3
"1" + "2"       // "12"
"1" + 2         // "12"
1 + {}          // "1[object Object]"

2 + null        // 2
2 + undefined   //NaN
```
- 加号可以进行加法以及字符串连接操作，因此结合性会导致结果的不同
```js
1 + 2 + " blind mice"        // "3 blind mice"
1 + ( 2 + " blind mice")     // "12 blind mice"
```

##### 一元运算符
- 具有很高的优先级
- 具有右结合性
- 一元加法+：把操作数转换为数字类型
- 一元减法-：把操作数转换为数字类型，并改变数字的符号
- 递增：
    - 对一个左值进行增量操作。先把操作数转换为一个数字类型并进行增量计算。
    - 后增量增量后返回未增量的左值。前增量增量后返回已增量的左值。
    - 注意++x并不总和x=x+1相同，因为++不会进行字符串连接操作
- 递减：与递增类似

##### 位运算符
- 位运算符要求它的操作数是整数。必要时，位运算符首先将操作数转换为数字，并将数字强制表示为32位整型，这会忽略原式中小数部分和任何超过32位的二进制位。
- 移位运算符要求右操作数在0~31之间，超过第五位的整数都会被舍弃。
- NaN，Infinity、-Infinity都会转换为0.
- 位操作符有&、|、^、~、<<、>>、>>>
- \<\<新添的位为0，移出的位将舍弃。左移相当于乘法
- \>>右移相当于除法。移出的位将舍弃，填补的位由原符号位决定。
- \>\>\>无符号位右移。填补的位都用0表示。

## 关系表达式
### 相等和不等运算符
- ===表示严格相等运算符，也叫做恒等运算符，不仅要求值相等、还要求类型相等
- ==表示相等，仅要求值相等，可以进行类型转换
- 对象的比较属于引用的比较，当其为同一引用时才相等
- 严格相等运算符：
    - 如果两个值的类型不相同，则它们不相等。
    - 若两个值都是null或者都是undefined，它们不相等（实测为相等）
    - 若两个值都是true或者都是false，它们相等
    - 若有一个NaN，两个值不相等。NaN与任何一个值都不相等，包括自身。因此可以使用x!=x以判断NaN值
    - 若两个值都是数字类型并且相等，则相等。0和-0相等。
    - 两个字符串长度相等并且对应位上的内容相等，则相等。
    - 两个对象属于同一引用，则相等。
- ==相等运算符，若两个值不为同一类型，则会进行类型转换：优先转为数字：
    - 如果一个为null，另一个为undefined，相等。
    - 如果一个值是数字，另一个是字符串，则都转换成数字后比较。
    - 如果一个值是true，则将其转换为1再比较，若一个一个值为false，将其转换为0再比较
    - 如果一个值是对象，另一个是数字或者字符串。JavaScript内置的类首先尝试使用valueOf()，再尝试使用toString()转换为原始值进行比较，除了日期类只使用toString()转换。
    - 其他类型的比较均认为是不相等

### 比较运算符
- 运算符：<、>、<=、>=
- 类型转换规则如下：
    - 如果操作数是对象，则对对象转换成为原始值：如果valueOf()返回一个原始值，那么直接使用这个原始值。否则使用toString()转换结果进行操作
    - 转换后，两个都是字符串，则进行字符串的比较
    - 至少有一个操作数不是字符串，那么两个操作数都将转换为数字进行数字的比较。
- 注意以ascii中0\~9：30\~39，A\~Z：41\~5A，a\~z:61\~7A
- 使用String.localCompare()方法来获取更多字符串比较的相关信息，可以使用String.toLowerCase()以及String.toUpperCase()转换后再比较字符串
- 相对于+号运算符，关系运算符更喜欢数字，运算符优先于转换为数字类型，当两个操作数都为字符串的时候才会进行字符串的比较，否则将转换成为数字进行比较
```js
1 + 2           // 3
"1" + "2"       // "12"
"1" + 2         // "12"
11 < 3          // false
"11" < 3        // false
"11" < "3"      // true
"one" < 3       // false
```
- 当关系运算符中出现一个NaN,都返回false

### in运算符
- in运算符希望其左操作数是一个字符串或者可以转换为字符串的量，右操作数是一个对象。
- 如果右侧的对象含有一个以左侧字符串为名的属性，则返回true，否则返回false.
```js 
var point = { x:1, y:1 };
"x" in point                // true
"z" in point                // false
"toString"  in point        // true, 继承了toString()方法

var data = [ 7, 8, 9];
"0" in data                 // true
1 in data                   // true
3 in data                   / false
```

### instanceof运算符
- 希望左操作数是一个对象，右操作数是一个标志对象的类。
- 如果左操作数是右侧类的实例，则表达式返回true，否则返回false
- JavaScript中的类通过初始化它们的构造函数来定义的，所以右侧应该是一个函数。
- 所有的对象都是Object的实例。
- 实例也包括了父类的检测。
- 左侧不是一个对象的时候，返回false。右侧不是一个函数，则抛出一个异常。
- instaceof原理：以`o instanceof f`为例，JS首先会计算f.prototype，然后再原型链中查找o，找到返回true，否则返回false
```js
var d = new Date();
d instanceof Date;      // true
d instanceof Object;    // true
d instanceof Number;    // false

var a = [1, 2, 3];      
a instanceof Array;     // true
a instanceof Object;    // true
a instanceof RegExp;    // false
```

### 逻辑表达式
##### 逻辑与（&&）
- 当第一个操作数为假值时，直接返回第一个操作数的值；当第一个操作数为真值时，返回第二个操作数。
- &&的运算优先性比||高
```js
var o = { x:1 };
var p = null;
o && o.x;           // 1
p && p.x;           // null
```
- &&的行为有时称为短路行为。可以利用这个特性有条件执行代码。
```js
if (a == b) stop();
(a == b) && stop();
```
- 当右侧表达式具有副作用的时候，副作用是否产生取决左侧表达式的真假

##### 逻辑或（||）
- 首先计算左侧表达式，若左侧表达式为真，直接返回左侧表达式结果；若左侧表达式为假，返回右侧表达式结果。
- 与&&相同，应当尽量避免右侧的表达式具有副作用
- 这个运算符最常用的方式可以用来从一组备选表达式中选出第一个正值表达式：
```js
var max = max_width || preference.max_width || 500;
```
- 其常用于函数体内，用来给参数提供默认值：
```js
function copy(o, p){
    p = p || {};        //如果没有传入p参数, 则创建一个新的对象
    ...
}
```
##### 逻辑非（！）
- 若为真值，返回false，若为假值，返回true
- ！总是将操作数转为布尔值，然后求反后返回一个布尔值
```js
!(p && q) === !p || !q; // true
!(p || q) === !p && !q; // true
```

### 赋值表达式
- 左侧是一个左值，右侧为任意值
- 赋值运算符具有很低的优先级
- 赋值运算符的结合性为从右到左

##### 带操作的赋值运算符
- 运算符：+=, -=, *=, /=, %=, <<=, >>=, >>>=, &=, |=, ^=
- `a op= b`等价于`a = a op b`,前式a计算了一次，后式a计算了两次，所以下式不等价
```js
data[i++] *= 2;
data[i++] = data[i++] * 2

// test result:
a=[1,2,3,4,5,6]
b=[1,2,3,4,5,6]
// (6) [1, 2, 3, 4, 5, 6]

i=j=2
// 2

a[i++] *= 2
// 6

a
// (6) [1, 2, 6, 4, 5, 6]

i
// 3

b[j++] = b[j++] * 2
// 8，先计算表达式中的值

b
// (6) [1, 2, 8, 4, 5, 6]

j
// 4
```

## 表达式计算
- 与其他解释性的语言一样，JavaScript同样可以解释运行由JS源代码组成的字符串，并产生一个值。
- eval()，执行参数中的字符串源代码，并返回一个值。
- eval()是一个函数，也可以看作是一个运算符。其可以赋予给其他的名字。
```js
var f = eval;
var g = f;
```
- eval()的问题在于：当今的JS解析器会对源代码进行分析及优化，而eval中的源代码则不能分析及优化

##### eval()
- eval()只有一个参数。如果传入的参数不是字符串，它将直接返回这个参数。如果参数是一个字符串，它会将字符串当成JavaScript代码进行编译。编译失败则抛出一个语法错误(SynataxError)异常。如果编译成功，则将执行这段代码，并返回字符串中的最后一个表达式或语句的值，如果最后一个表达式或者语句没有值，则最终返回undefined。如果字符串抛出异常，则直接将这个异常传递给eval()。
- eval()使用了调用所在位置的变量作用域环境。
- ES3规定了不允许对eval()赋予别名。如果使用eval()函数通过别名调用的话，则会抛出一个EvalError异常。
- 实际上，大多数的实现就是，通过别名调用eval()时，eval()中的字符串会当做顶层的全局代码执行，使用的是全局作用域。
```js
    var geval = eval;
        var x = "global", y = "global";
        function f(){
            var x = "local";
            eval("x += 'changed';");
            return x;
        }

        function g(){
            var y = "local";
            geval("y += 'changed';");
            return y;
        }

        console.log(f(),x); // localchanged global
        console.log(g(),y); // local globalchanged
```
- ES5严格模式对eval()函数的行为有了更多的限制。eval执行的代码段可以查询或更改局部变量，当不能再局部作用域中定义新的变量或者函数。严格模式将eval列为保留字，让eval更像一个运算符，不能使用给一个别名覆盖eval函数。变量名、函数名以及函数参数等单数不能取名为eval。

## 其他运算符
### 条件运算符(?:)
```js
greeetin = "hello" + (username ? username : "there");
```
### typeof运算符
x               |  typeof x
---             | ---
undefined       | "undefined"
null            | "obeject"
true或者false   | "boolean"
任意数字或NaN   | "number"
任意字符串      | "string"
任意函数        | "function"
任意内置对象    | "object"
任意宿主对象    | 编译器各自实现的字符串
```js
(typeof value == "string") ? "'" + value "'": value;

typeof(i)       // 可以加上圆括号使得typeof更像一个函数而不是一个运算符
```
- null也属于object，因此区分null和对象，则必须针对特殊值进行特殊检测
- 区分对象的类需要使用其他的手段，例如使用instanceof运算符、class特性以及constructor属性
- 函数和“可执行对象”有着微妙的区别。

##### delete 运算符
- delete用于删除对象的属性以及数组元素
- delete像赋值、递增、递减运算符一样，具有副作用
```js
var o = {
    x : 1,
    y : 2,
}

delte o.x;
"x" in o        // false, 这个属性已经不存在

var a = [1, 2, 3];
delete a[2];
2 in a;         // false, 元素2已经删除
a.length        // 3, 长度没有改变，只是留下一个“洞”
```
- 删除成功，delete返回一个true。若删除的不是一个左值，delete不进行操作并返回一个true。
- 不可删除的元素：
    - 内置核心以及客户端
    - var声明的变量
    - function语句定义的函数和函数参数
    - ES5，delete的操作是非法的，比如变量、函数、函数参数等，delete操作将会抛出一个语法错误异常，严格模式下，delete删除不可配置的属性会抛出一个类型错误异常。非严格模式下，delete操作不会报错，只是返回一个false。
```js 
var o = {x:1, y:2};         // 定义一个变量， 初始化为对象
delete o.x;                 // 删除一个对象属性，返回true
typeof o.x;                 // 属性已经不存在，返回"undefined"
delete o.x;                 // 删除不存在的属性，返回true
delete o;                   // 不能删除通过var声明的变量，返回false
                            // 严格模式下，抛出一个语法异常
delete 1;                   // 删除一个左值，返回ture
this.x = 1;                 
delete x;                   // 删除没有用var声明的变量

x;                          // 运行出错，不存在x
```

##### void运算符
- void是一个一元运算符，其后面跟一个操作数
- 操作数会照常计算，当忽略计算结果并返回undefined
```html
<a href="javascript:void window.open();">打开一个新窗口</a>
```

##### 逗号运算符
- 逗号运算符是一个二元运算符，它的操作数可以是任意类型。
- 首先计算左操作数，然后计算右操作数，最后返回右操作数的值。
```js
i = 0, j = 1, k = 2;    // 计算结果为2
```